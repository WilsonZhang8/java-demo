package com.zghw.base.generic;
/**
 * 泛型方法
	泛型方法使得该方法能够独立于类而发生改变。这个方法锁在的类可以时泛型类，也可以不是泛型类。
是否拥有泛型方法，与其所在的类是否是泛型没有关系
	无论何时，只要你能做到，你就应该尽量使用泛型方法。如果使用泛型方法可以取代将整个类型泛型化，那么就应该只
使用泛型方法，因为它可以使事情更清楚明白。
	对于一个static的方法而言，无法访问泛型类的类型参数，所以，如果static方法需要使用泛型能力，就必须使其成为泛型
方法。	
	要定义泛型方法，只需将泛型参数列表置于返回值之前	
 * @author zghw
 *
 */
//GenericMethods并不是参数化的，尽管这个类和其内部方法可以被同时参数化，但是阻止由方法f()拥有类型参数
//这是由该方法的返回类型前面的类型参数列表指明的
public class GenericMethods {
	public <T> void f(T t){
		System.out.println(t.getClass().getName());
	}
	public static void main(String[] args) {
		//在使用泛型类时，必须在创建对象的时候指定参数类型的值，而使用泛型方法的时候，不必指明参数类型。
		//因为编译器会为我们找出具体的类型。这被成为类型参数推断
		GenericMethods gm =new GenericMethods();
		//我们可以像调用普通方法一样调用f()，而且好像是f()被无限次地重载过。它甚至可以接受GenericMethods
		//作为其类型参数
		//如果调用f()时传入地基本类型，自动打包机制就会介入其中，将基本类型的值包装为对应的对象。
		//事实上，泛型方法与自动打包避免了许多以前我们不得不自己编写出来的代码。
		gm.f("");
		gm.f(1);
		gm.f(1.0);
		gm.f(1.0F);
		gm.f('c');
		gm.f(gm);
	}

}
